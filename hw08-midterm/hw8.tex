\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}

\usepackage[normalem]{ulem}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = black, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor    = blue  %Colour of citations
}

\usepackage{multirow}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\usepackage[table]{xcolor}
\usepackage{color}
\usepackage{colortbl}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{gray}{rgb}{0.7,0.7,0.7}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\theoremstyle{definition}
\newtheorem{problem}{Problem}
\newcommand{\E}{\mathbb E}
\newcommand{\R}{\mathbb R}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\newcommand{\trans}[1]{{#1}^{T}}
\newcommand{\loss}{\ell}
\newcommand{\w}{\mathbf w}
\newcommand{\x}{\mathbf x}
\newcommand{\y}{\mathbf y}
\newcommand{\ltwo}[1]{\lVert {#1} \rVert}

\newcommand{\ignore}[1]{}

\usepackage{listings}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
stepnumber=1,
numbers=left
}}

\lstnewenvironment{python}[1][]
{
    \pythonstyle
    \lstset{#1}
}
{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{center}
    {
\Large
CSCI046 Midterm
}

    %\vspace{0.1in}
%CSCI046, Mike Izbicki

    \vspace{0.1in}
    \textbf{DUE: Friday, 13 March by noon}

    \vspace{0.1in}
\end{center}

\noindent
\textbf{Collaboration policy:} 

\vspace{0.1in}
\noindent
You may not:
\begin{enumerate}
    \item discuss the midterm exam with a human other than Mike; this includes:
        \begin{enumerate}
            \item asking your friend for clarification about what a problem is asking
            \item asking your friend if they've completed the exam
        \end{enumerate}
        %\noindent(this includes talking about whether you have finished the exam yet)
\end{enumerate}

\noindent
You may:
\begin{enumerate}
    \item take as much time as needed
    \item use any written notes / electronic resources you would like
    \item ask Mike to clarify questions
\end{enumerate}


\vspace{0.15in}

\vspace{0.25in}
\noindent
Name: 

\noindent
\rule{\textwidth}{0.1pt}
\vspace{0.15in}


\newpage
\begin{problem}
(2 pts)
    %For each row below, circle $O$ if $f=O(g)$ and $\Omega$ if $f=\Omega(g)$.
    %If $f=\Theta(g)$, then circle both $O$ and $\Omega$.
    Complete each equation below by adding the symbol $O$ if $f=O(g)$, $\Omega$ if $f=\Omega(g)$, or $\Theta$ if $f=\Theta(g)$.  
    The first row is completed for you as an example.

{\renewcommand{\arraystretch}{3.4}
\begin{tabular}{c c c c c c}
    & f(n) &~\hspace{0.5in}~$ $~\hspace{0.5in}~& g(n) &\\
    \hline
    & $1$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $O(n)$ &  &\\
    \arrayrulecolor{gray}\hline
    & $1.1^n$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $n^2$ &  &\\
    \arrayrulecolor{gray}\hline
    & $1/n$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $1$ &  &\\
    \arrayrulecolor{gray}\hline
    & $\log_4 n$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $\log_3 n$ &  &\\
    \arrayrulecolor{gray}\hline
    & $2^{n}$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $n^2$ &  &\\
    \arrayrulecolor{gray}\hline
    & $\log n$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $\sqrt n$ &  &\\
    \arrayrulecolor{gray}\hline
    & $\log (n^3)$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $\log n$ &  &\\
    \arrayrulecolor{gray}\hline
    & $\log (n!)$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $n\log n$ &  &\\
    \arrayrulecolor{gray}\hline
    & $n!$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $n^2$ &  &\\
    \arrayrulecolor{gray}\hline
    & $(\log n)^4$ & ~\hspace{0.5in}~$=$~\hspace{0.5in}~  & $(\log n)^3$ &  &\\
    \arrayrulecolor{gray}\hline

    %& $O(1)$ & or & $O(n)$ & or & equal\\
    %& $O(n\log n)$ & or & $O(n^2)$ & or & equal\\
    %& $\Theta(1)$ & or & $\Theta(1/n)$ & or & equal\\
    %& $\Omega(\log_2 n)$ & or & $\Omega(\log_3 n)$ & or & equal\\
    %& $O(n^{42})$ & or & $O(42^n)$ & or & equal\\
    %& $\Theta(5\cdot10^{30})$ & or & $\Theta(\log n)$ & or & equal\\
    %& $\Omega(\log n)$ & or & $\Omega(\log (n^2))$ & or & equal\\
    %& $O(2^n)$ & or & $O(3^n)$ & or & equal\\
    %& $\Theta(n!)$ & or & $\Theta(n^2)$ & or & equal\\
    %& $\Omega(\log n)$ & or & $\Omega((\log n)^2)$ & or & equal\\
\end{tabular}
}
\end{problem}

\newpage
\begin{problem}
(1 pt) 
    Fill in the table with the appropriate runtimes in theta notation.
    You do not need to fill in the gray-ed out entries.

    \vspace{0.15in}
{\renewcommand{\arraystretch}{3.4}
    \begin{tabular}{|l|C{1in}|C{1in}|C{1in}|C{1in}|}
        %&~\hspace{1.5in}~&~\hspace{1.5in}~&~\hspace{1.5in}~\\
        \hline
        & \multicolumn{3}{|c|}{run time} & \multirow{2}{*}{memory usage} \\
        \cline{2-4}
        & best case & worst case & average case &              \\
        \hline
        bubble sort &&&&\\
        \hline
        selection sort &&&&\\
        \hline
        insertion sort &&&&\\
        \hline
        merge sort &&&&\\
        \hline
        quick sort &&&&\\
        \hline
        tim sort &&&&\\
        \hline
    \end{tabular}
    }
    \vspace{0.15in}
\end{problem}
\begin{problem}
    (1 pt)
    What is a tight lower bound on the runtime (in omega notation) of the best possible comparison-based sorting algorithm?
\end{problem}

\newpage
\begin{problem}
(2 pts)
Consider the following two functions:
\begin{python}
def print_container_1(xs):
    for i in range(len(xs)):
        print('xs[i]=',xs[i])

def print_container_2(xs):
    for x in xs:
        print('x=',x)
\end{python}
Notice that both functions will work whether the \texttt{xs} parameter is a list or a deque.
Whenever a function works for more than one type of input, we call it \textbf{polymorphic}.
\begin{enumerate}
    \item 
        Assume we have a \textbf{list} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_1} on this list?
        (Use big-O notation.)
        \vspace{1in}
    \item 
        Assume we have a \textbf{list} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_2} on this list?
        (Use big-O notation.)
        \vspace{1in}
    \item 
        Assume we have a \textbf{deque} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_1} on this deque?
        (Use big-O notation.)
        \vspace{1in}
    \item 
        Assume we have a \textbf{deque} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_2} on this deque?
        (Use big-O notation.)
        \vspace{1in}
\end{enumerate}
\end{problem}

\ignore{
\newpage
\begin{problem}
Consider the following python function.
\begin{python}
def foo(xs,ys):
    for x in xs:
        if x in ys:
            print('x in ys for x=',x)
\end{python}
Notice that \texttt{foo} is polymorphic in both \texttt{xs} and \texttt{ys}.
\begin{enumerate}
    \item 
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{list} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
    \item
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{deque} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
    \item
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{set} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
    \item
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{dict} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
\end{enumerate}
\end{problem}
}

\ignore{
\newpage
\begin{problem}
    Use iterative substitution to solve the following recurrence relation in big-O notation.
    \begin{equation*}
        T(n) = T(n-3) + n
    \end{equation*}
\end{problem}


\newpage
\begin{problem}
    Use iterative substitution to solve the following recurrence relation in big-O notation.
    \begin{equation*}
        T(n) = 3T(n/3) + 1
    \end{equation*}
\end{problem}

\newpage
\begin{problem}
    Use iterative substitution to solve the following recurrence relation in big-O notation.
    \begin{equation*}
        T(n) = T(n/3) + 1
    \end{equation*}
\end{problem}
}




\newpage
\begin{problem}
    We saw in class that binary search runs in logrithmic time.
    One possible idea for speeding up the computation is to perform trinary search
    (that is, split the list into three sections rather than two on each recursive call).
    The following code implements trinary search.
\begin{python}
def trinary_search(xs,val):
    left = 0
    right = len(xs)
    def go(left,right):
        if right-left<3:
            return val in xs[left:right]
        mid1 = left + (right-left)//3
        mid2 = left + (right-left)//3*2
        if val < xs[mid1]:
            return go(left,mid1)
        elif val < xs[mid2]:
            return go(mid1,mid2)
        else:
            return go(mid2,right)
    return go(left,right)
\end{python}

    \begin{enumerate}
        \item
            (2 pts)
            What is the recurrence relation describing the runtime of \texttt{trinary\_search}?

        \newpage
        \item
            (2 pts)
            Solve the recurrence relation you gave for part 1.
            (You can get full credit on this problem even if you gave the wrong answer on the previous problem.)
    \end{enumerate}
\end{problem}
\end{document}
