\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}

\usepackage[normalem]{ulem}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = black, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor    = blue  %Colour of citations
}

\usepackage{color}
\usepackage{colortbl}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{gray}{rgb}{0.7,0.7,0.7}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\theoremstyle{definition}
\newtheorem{problem}{Problem}
\newcommand{\E}{\mathbb E}
\newcommand{\R}{\mathbb R}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\newcommand{\trans}[1]{{#1}^{T}}
\newcommand{\loss}{\ell}
\newcommand{\w}{\mathbf w}
\newcommand{\x}{\mathbf x}
\newcommand{\y}{\mathbf y}
\newcommand{\ltwo}[1]{\lVert {#1} \rVert}

\newcommand{\ignore}[1]{}

\usepackage{listings}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
stepnumber=1,
numbers=left
}}

\lstnewenvironment{python}[1][]
{
    \pythonstyle
    \lstset{#1}
}
{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{center}
    {
\Large
CSCI046 Homework 5: Scope and Memory Management
}

    %\vspace{0.1in}
%CSCI046, Mike Izbicki

    \vspace{0.1in}
    \textbf{DUE: Thursday, 27 February beginning of class}

    \vspace{0.1in}
\end{center}

\vspace{0.25in}
\noindent
Name: 

\noindent
\rule{\textwidth}{0.1pt}
\vspace{0.15in}

\noindent
\textbf{Collaboration policy:} 
You are allowed to use any resources you would like to complete this assignment,
and you are encouraged to work in teams.
Remember, learning the material is your responsibility,
so collaborate in a way that will help you learn.

\textbf{I highly recommend that you first try to evaluate the python code without a computer, and only use a computer to check your work.
}
If you don't understand a problem, then use \url{https://pythontutor.com} to go step by step through the code.
\vspace{0.15in}

\noindent
\textbf{Note:}
By default, all variables are \textbf{global} and accessible anywhere inside or outside a function.
A variable becomes \textbf{local} if it defined within a function and the \texttt{global} keyword is not used.

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    print('xs=',xs)
foo()
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    xs = 'a'
    print('xs=',xs)
foo()
\end{python}
\end{problem}
\vspace{1in}

\newpage
\noindent
\textbf{Note:}
Modifying a global variable does not make the variable local.
The only way to make a variable local is if it appears to the left of an equals sign \emph{by itself}
(i.e.\ appearing to the left of an equal sign does not matter if there is a slice).
Calling a function that modifies a variable does not make a variable local.

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    xs = 'a'
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    xs[-1] = 'a'
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1.5in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    xs.pop()
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1.5in}

\newpage

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    xs.append('a')
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1.5in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    xs.pop()
def bar():
    global xs
    xs = [4,5,6]
    xs.append('a')
foo()
bar()
bar()
foo()
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1.5in}


\newpage
\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    xs = [4,5,6]
    xs.append('a')
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    xs = [4,5,6]
    xs.append('a')
    print('xs=',xs)
foo()
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo():
    global xs
    xs = [4,5,6]
    xs.append('a')
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\newpage
\begin{problem}
\sout{Write the output of the following python code.}
The following code causes an error in python.
Enter the code into the python interpreter;
make sure you understand the error message and why the error is occurring.
You do not have to write anything for this problem.
\begin{python}
xs = [1,2,3]
def foo():
    xs.append('a')
    xs = [4,5,6]
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
Write the output of the following python code.
%\textbf{Ensure that you understand why this code is okay,
%but the previous problem causes an error.}
\begin{python}
xs = [1,2,3]
def foo():
    global xs
    xs.append('a')
    xs = [4,5,6]
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\newpage
\noindent
\textbf{Note:}
Assignment makes two variable names refer to the same object.
Changing the contents of one variable actually changes the contents of the object,
and therefore changes the contents of both variables.
In order to create new, distinct, objects, you must copy the variable.

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
ys = xs
ys.append('a')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
Write the output of the following python code.
\begin{python}
import copy
xs = [1,2,3]
ys = copy.copy(xs)
ys.append('a')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\newpage
\noindent
\textbf{Note:}
When lists contain non-container objects like integers, \texttt{copy} and \texttt{deepcopy} behave exactly the same way.
When lists contain containers, then copy and deep copy behave differently.

\begin{problem}
Write the output of the following python code.
\begin{python}
import copy
xs = [[1,2,3],[4,5,6]]
ys = copy.copy(xs)
ys[0][0] = 'a'
xs[1][1] = 'b'
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
What is the output of the previous code if we change \texttt{copy.copy} to \texttt{copy.deepcopy}?
%Write the output of the following python code.
%\begin{python}
%import copy
%xs = [[1,2,3],[4,5,6]]
%ys = copy.deepcopy(xs)
%ys[0][0] = 'a'
%xs[1][1] = 'b'
%print('xs=',xs)
%print('ys=',ys)
%\end{python}
\end{problem}
\vspace{2in}

\newpage
\begin{problem}
Write the output of the following python code.
\begin{python}
import copy
xs = [[1,2,3],[4,5,6]]
ys = copy.copy(xs)
ys.append('a')
ys[0].append('b')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
What is the output of the previous code if we change \texttt{copy.copy} to \texttt{copy.deepcopy}?
%\begin{python}
%import copy
%xs = [[1,2,3],[4,5,6]]
%ys = copy.deepcopy(xs)
%ys.append('a')
%ys[0].append = 'b'
%print('xs=',xs)
%print('ys=',ys)
%\end{python}
\end{problem}
\vspace{2in}
%\newpage
%\begin{problem}
%Write the output of the following python code.
%\begin{python}
%import copy
%xs = [1,2,3]
%ys = copy.copy(xs)
%ys[0] = 'a'
%ys = xs
%print('xs=',xs)
%print('ys=',ys)
%\end{python}
%\end{problem}
%\vspace{2in}
%
%\begin{problem}
%Write the output of the following python code.
%\begin{python}
%xs = [1,2,3]
%ys = copy.copy(xs)
%ys.append(4)
%print('xs=',xs)
%print('ys=',ys)
%\end{python}
%\end{problem}

\newpage
\noindent
\textbf{Note:}
Variables that are parameters to a function are always local variables.
But, if a default parameter is used, these objects are only created once and the same copy is used in all subsequent calls that require a default parameter.

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
def foo(xs=[]):
    print('xs=',xs)
    xs.append(len(xs)+1)
foo()
foo()
foo()
foo([])
foo()
foo()
\end{python}
\end{problem}
\vspace{1.5in}

\noindent
\textbf{Note:}
Unfortunately, default parameters behave differently for container objects and non-container objects.

\begin{problem}
Write the output of the following python code.
\begin{python}
n = 7
def foo(n=0):
    print('n=',n)
    n+=1
foo()
foo()
foo()
foo(1)
foo()
foo()
\end{python}
\end{problem}
\vspace{2in}

\newpage
\noindent
\textbf{Note:}
The following problems illustrate different ways that you might try to reverse a list in python.
At first glance, they all look the same.
Due to memory management issues, however, they are not all correct.
Understanding memory management is important when tracking down these subtle bugs.

\begin{problem}
Write the output of the following python code.
\begin{python}
def reverse_list(xs):
    ys = xs
    for i in range(len(ys)):
        ys[i] = xs[-i-1]
    return ys

xs = [1,2,3]
ys = reverse_list(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
Write the output of the following python code.
\begin{python}
import copy
def reverse_list(xs):
    ys = copy.copy(xs)
    for i in range(len(ys)):
        xs[i] = ys[-i-1]
    return ys

xs = [1,2,3]
ys = reverse_list(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{1.5in}

\newpage
\begin{problem}
Write the output of the following python code.
\begin{python}
import copy
def reverse_list(xs):
    ys = copy.copy(xs)
    for i in range(len(ys)):
        ys[i] = xs[-i-1]
    return ys

xs = [1,2,3]
ys = reverse_list(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
Write the output of the following python code.
\begin{python}
def reverse_list():
    ys = xs
    for i in range(len(ys)):
        ys[i] = xs[-i-1]
    return ys

xs = [1,2,3]
ys = reverse_list()
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}


\newpage
\noindent
\textbf{Note:}
Because reversing a list is a common task,
python provides two inbuilt methods to accomplish it.
The \texttt{reverse} function does not create a copy of a list, but instead changes the list in place.
The \texttt{reversed} function makes a copy of the list, reverses the copy, and leaves the original list unmodified.
Both functions are widely used in python code.

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
ys = xs.reverse()
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
ys = list(reversed(xs))
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}

\newpage
\noindent
\textbf{Note:}
Sorting is another common task, and python contains two functions for sorting lists: \texttt{sort} and \texttt{sorted}.
It is a python convention that any function in the past tense returns a copy of the list without modifying the list, 
and any function written in the imperative modifies the list in place.

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [2,3,1]
ys = xs.sort()
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [2,3,1]
ys = list(sorted(xs))
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}

\newpage
\noindent
\textbf{Note:}
Internally, the \texttt{reversed} and \texttt{sorted} functions perform shallow copies instead of deep copies.

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [[1,2,3],[4,5,6]]
ys = list(reversed(xs))
ys.append('a')
ys[0].append('b')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
Write the output of the following python code.
\begin{python}
import copy
xs = [[1,2,3],[4,5,6]]
ys = list(reversed(copy.deepcopy(xs)))
ys.append('a')
ys[0].append('b')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}

\newpage
\noindent
\textbf{Note:}
It is fairly common to define functions within functions in python.
These are called ``local functions'' because they are only accessible from within the outer function (just like local variables).
These problems are designed to give you practice understanding how scope works in these local functions.

\begin{problem}
Write the output of the following python code.
\begin{python}
x = 'a'
xs = [1,2,3]
def foo():
    x = 'b'
    xs = [1,2,3]
    def bar():
        x = 'c'
        xs[0] = 'd'
    bar()
    print('x=',x)
    print('xs=',xs)
foo()
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
Write the output of the following python code.
\begin{python}
x = 'a'
xs = [1,2,3]
def foo():
    global xs
    x = 'b'
    xs = [1,2,3]
    def bar():
        global x
        x = 'c'
        xs[0] = 'd'
    bar()
    print('x=',x)
    print('xs=',xs)
foo()
\end{python}
\end{problem}

\newpage
\noindent
\textbf{Note:}
The next set of problems use recursion.
Remember that everytime a function is called, a new frame is created that has new local variables.

%\begin{problem}
%Write the output of the following python code.
%\begin{python}
%xs = []
%def foo(xs,i):
%if i>3:
    %return
%xs.append(i)
%foo(xs,i+1)
%print('i=',i,'xs=',xs)
%foo(xs,0)

%\end{python}
%\end{problem}
%\vspace{2in}

%\begin{problem}
%Write the output of the following python code.
%\begin{python}
%xs = []
%def foo(i):
    %print('i=',i,'xs=',xs)
    %if i>3:
        %return
    %xs.append(i)
    %foo(i+1)
%foo(0)
%\end{python}
%\end{problem}
%\vspace{2in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = []
def foo(i):
    print('i=',i,'xs=',xs)
    if i>3:
        return
    xs.append(i)
    foo(i+1)
foo(0)
\end{python}
\end{problem}
\vspace{2in}


\begin{problem}
Write the output of the following python code.
\begin{python}
x = 0
def foo(y):
    global x
    x += 1
    print('x=',x,'y=',y)
    if y==0:
        return
    foo(y-1)
    print('x=',x,'y=',y)
foo(3)
\end{python}
\end{problem}

\newpage
\noindent
\textbf{Note:}
These final problems combine recusion, memory management, and scope issues on the practical problem of reversing a list.
Notice that you must pay close attention to these issues or you can accidentally corrupt your input data.

\begin{problem}
Write the output of the following python code.
\begin{python}
def reverse_recursive(xs):
    def go(xs,ys):
        if len(xs)==0:
            return ys
        ys.append(xs.pop())
        return go(xs,ys)
    return go(xs,[])

xs = [1,2,3]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
Write the output of the following python code.
\begin{python}
def reverse_recursive(xs):
    import copy
    xs = copy.copy(xs)
    def go(xs,ys):
        if len(xs)==0:
            return ys
        ys.append(xs.pop())
        return go(xs,ys)
    return go(xs,[])

xs = [1,2,3]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\newpage
\noindent
\textbf{Note:}
Combining recursion with default parameters is potentially dangerous.

\begin{problem}
Write the output of the following python code.
\begin{python}
def reverse_recursive(xs,ys=[]):
    import copy
    xs = copy.copy(xs)
    if len(xs)==0:
        return ys
    ys.append(xs.pop())
    return reverse_recursive(xs,ys)

xs = [1,2,3]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)

xs = [4,5,6]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\newpage

\begin{problem}
Write the output of the following python code.
\begin{python}
def reverse_recursive(xs,ys=None):
    import copy
    xs = copy.copy(xs)
    if ys is None:
        ys = []
    if len(xs)==0:
        return ys
    ys.append(xs.pop())
    return reverse_recursive(xs,ys)

xs = [1,2,3]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)

xs = [4,5,6]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\noindent
\textbf{Note:}
There are many ways in python to make shallow copies of containers besides using \texttt{copy.copy}.

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
ys = xs[:]
ys.append('a')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3]
ys = list(xs)
ys.append('a')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\newpage
\noindent
\textbf{Note:}
Modifying a container that you are looping over is dangerous;
strange behavior can occur depending on how you modify the container.
We call these errors ``silent errors'' because they do not generate error messages.

Silent errors are one of the most insidious sources of programming bugs because they are so difficult to detect.
Unfortunately, python is notorious for these silent errors due to its weak type system.
Other languages (like C++, Java, and Haskell) have much stronger type systems that prevent certain classes of silent errors from ever occuring.

If you want to modify a container inside a for loop,
you should probably instead loop over a copy of the container to prevent unintended behavior.

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3,4,5]
for x in xs:
    print('x=',x)
    xs.pop()
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3,4,5]
for x in xs:
    print('x=',x)
    del xs[0]
\end{python}
\end{problem}
\vspace{2in}

\newpage
\begin{problem}
Write the output of the following python code.
\begin{python}
xs = [1,2,3,4,5]
for x in list(xs):
    print('x=',x)
    xs.pop()
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
\sout{Write the output of the following python code.}
Not all containers allow modification in the middle of a loop;
the following code tries to modify a \texttt{deque} and generates an error.
These error messages are good, and follow the so-called ``fail loudly'' principle.
The inconsistency that some containers fail loudly and some fail silently is one of python's major flaws (IMNSHO).
You do not have to write anything for this problem (but you should type it into the python interpreter).

\begin{python}
from collections import deque
xs = deque([1,2,3,4,5])
for x in xs:
    print('x=',x)
    del xs[0]
\end{python}
\end{problem}
\vspace{2in}


\ignore{
\newpage
\begin{problem}
Consider the following two functions:
\begin{python}
def print_container_1(xs):
    for i in range(len(xs)):
        print('xs[i]=',xs[i])

def print_container_2(xs):
    for x in xs:
        print('x=',x)
\end{python}
Notice that both functions will work whether the \texttt{xs} parameter is a list or a deque.
Whenever a function works for more than one type of input, we call it \textbf{polymorphic}.
\begin{enumerate}
    \item 
        Assume we have a \textbf{list} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_1} on this list?
        (Use big-O notation.)
        \vspace{1in}
    \item 
        Assume we have a \textbf{list} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_2} on this list?
        (Use big-O notation.)
        \vspace{1in}
    \item 
        Assume we have a \textbf{deque} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_1} on this deque?
        (Use big-O notation.)
        \vspace{1in}
    \item 
        Assume we have a \textbf{deque} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_2} on this deque?
        (Use big-O notation.)
        \vspace{1in}
\end{enumerate}
\end{problem}

\newpage
\begin{problem}
Consider the following python function.
\begin{python}
def foo(xs,ys):
    for x in xs:
        for y in ys:
            print('x,y=',x,y)
    for x in xs:
        print('x=',x)
    for y in ys:
        print('y=',y)
\end{python}
Notice that \texttt{foo} is polymorphic in the sense that both \texttt{xs} and \texttt{ys} can be any container type (list, deque, set, dict, etc.).
\begin{enumerate}
    \item 
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{list} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
    \item
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{set} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
\end{enumerate}
\end{problem}

\begin{problem}
Consider the following python function.
\begin{python}
def foo(xs,ys):
    for x in xs:
        if x in ys:
            print('x in ys for x=',x)
\end{python}
Notice that \texttt{foo} is polymorphic in the sense that both \texttt{xs} and \texttt{ys} can be any container type (list, deque, set, dict, etc.).
\begin{enumerate}
    \item 
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{list} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
    \item
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{set} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
\end{enumerate}
\end{problem}
}
\end{document}
